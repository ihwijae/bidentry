const fs = require('fs');
const path = 'automation-engine/src/sites/nxCertificate.js';
const content = `"use strict";

async function handleNxCertificate(siteLabel, page, emit, cert = {}, extra = {}) {
  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
  const prefix = `[${siteLabel || 'CERT'}]`;
  const log = (level, msg) => emit && emit({ type: 'log', level, msg: `${prefix} ${msg}` });

  if (!page) {
    log('error', 'Playwright page handle missing');
    return { ok: false, error: 'Playwright page handle missing' };
  }

  const context = page.context?.();
  const knownPages = new Set(context ? context.pages() : [page]);

  const defaultSelectors = [
    '#browser-guide-added-wrapper #nx-cert-select',
    '#nx-cert-select',
    '.nx-cert-select',
    '#browser-guide-added-wrapper'
  ];
  const selectors = [...(Array.isArray(extra?.selectors) ? extra.selectors : []), ...defaultSelectors];

  const rowSelectors = [...(Array.isArray(extra?.rowSelectors) ? extra.rowSelectors : []), '#NXcertList tr'];
  const pinSelectors = [
    ...(Array.isArray(extra?.pinSelectors) ? extra.pinSelectors : []),
    '#certPwd',
    'input#certPwd',
    'input[name="certPwd"]',
    '#nx_cert_pin',
    'input[name="nx_cert_pin"]',
    'input[type="password"]'
  ];
  const confirmSelectors = [
    ...(Array.isArray(extra?.confirmSelectors) ? extra.confirmSelectors : []),
    '#nx-cert-select button.btn-ok',
    '#browser-guide-added-wrapper button.btn-ok',
    '.pki-bottom button.btn-ok',
    'button:has-text("확인")'
  ];

  const timeoutMs = Number(extra?.timeoutMs) || 20000;
  const start = Date.now();

  async function locateModal() {
    while (Date.now() - start < timeoutMs) {
      const pages = context ? context.pages() : [page];
      for (const current of pages) {
        const scopes = [current, ...(current.frames?.() || [])];
        for (const scope of scopes) {
          for (const sel of selectors) {
            if (!sel) continue;
            try {
              const handle = await scope.$(sel);
              if (handle) {
                return { certPage: current, scope };
              }
            } catch {}
          }
        }
      }
      await sleep(200);
    }
    return null;
  }

  const located = await locateModal();
  if (!located) {
    log('error', 'Certificate modal not detected within timeout');
    return { ok: false, error: 'Certificate modal not detected' };
  }

  const certPage = located.certPage;
  const scope = located.scope;
  log('info', `Certificate modal located (url=${certPage.url?.() || ''})`);

  const preferSubject = String(cert.subjectMatch || cert.subject || extra?.subject || extra?.company?.name || '').trim();
  const preferIssuer = String(cert.issuerMatch || cert.provider || '').trim();
  const preferSerial = String(cert.serialMatch || cert.serial || '').trim();
  const pinValue = String(cert.pin || cert.password || '').trim();

  async function applyMediaPreference() {
    const raw = String(cert.media || cert.storage || '').trim();
    if (!raw) return;
    const normalized = raw.toLowerCase();
    const tags = [normalized];
    if (/usb|move|remov/.test(normalized)) tags.push('usb');
    if (/hdd|hard|disk|pc|local/.test(normalized)) tags.push('hdd');
    if (/browser|web/.test(normalized)) tags.push('browser');
    if (/file|pfx|p12|finder/.test(normalized)) tags.push('fcert');
    if (/token|hsm|bio/.test(normalized)) tags.push('hsm');
    const clicked = await scope.evaluate((prefs) => {
      const norm = (s) => (s || '').toLowerCase();
      const buttons = Array.from(document.querySelectorAll('#cert-location-area-select-media button, #cert-location-area-targetMedia button, #cert-location-area button'));
      for (const btn of buttons) {
        const id = norm(btn.id);
        const text = norm(btn.textContent || '');
        const title = norm(btn.getAttribute('title') || '');
        const dataset = norm(btn.getAttribute('onclick') || '');
        for (const pref of prefs) {
          if (!pref) continue;
          if (id.includes(pref) || text.includes(pref) || title.includes(pref) || dataset.includes(pref)) {
            btn.click();
            btn.classList?.add('active');
            return true;
          }
        }
      }
      return false;
    }, tags).catch(() => false);
    if (clicked) {
      log('info', `Media preference applied (${raw})`);
      await sleep(150);
    } else {
      log('warn', `Requested media '${raw}' not found; defaulting to active media`);
    }
  }

  await applyMediaPreference();

  const selection = await scope.evaluate((prefs) => {
    const norm = (s) => (s || '').toLowerCase().replace(/[\\s\\u00a0\-_/()\\[\\]]/g, '');
    const wantSubject = norm(prefs.subject);
    const wantIssuer = norm(prefs.issuer);
    const wantSerial = norm(prefs.serial);

    const selectors = (prefs.rowSelectors && prefs.rowSelectors.length)
      ? prefs.rowSelectors
      : ['#NXcertList tr', '.nx-cert-list tr', '.cert-list tbody tr', '.cert-list tr'];

    const rows = [];
    const seen = new Set();
    for (const sel of selectors) {
      if (!sel) continue;
      try {
        const found = Array.from(document.querySelectorAll(sel));
        for (const row of found) {
          if (!seen.has(row)) {
            seen.add(row);
            rows.push(row);
          }
        }
      } catch {}
    }

    if (!rows.length) {
      const fallback = Array.from(document.querySelectorAll('table tr'));
      for (const row of fallback) {
        if (!seen.has(row)) {
          seen.add(row);
          rows.push(row);
        }
      }
    }

    if (!rows.length) {
      return { ok: false, reason: 'no_rows' };
    }

    let bestIdx = -1;
    let bestScore = -Infinity;
    rows.forEach((row, idx) => {
      const text = row.innerText || row.textContent || '';
      const ntext = norm(text);
      let score = 0;
      if (wantSerial && ntext.includes(wantSerial)) score += 500;
      if (wantSubject && ntext.includes(wantSubject)) score += 220;
      if (wantIssuer && ntext.includes(wantIssuer)) score += 80;
      if (!wantSerial && !wantSubject && !wantIssuer) score += Math.max(0, rows.length - idx);
      if (score > bestScore) {
        bestScore = score;
        bestIdx = idx;
      }
    });

    if (bestIdx < 0) bestIdx = 0;
    const target = rows[bestIdx];
    if (!target) {
      return { ok: false, reason: 'no_target' };
    }
    target.scrollIntoView?.({ block: 'center' });
    target.click?.();
    target.focus?.();
    target.classList?.add('on');
    const cells = Array.from(target.querySelectorAll('td, th')).map((c) => (c.innerText || c.textContent || '').trim());
    return { ok: true, index: bestIdx, text: (target.innerText || '').trim(), cells };
  }, {
    subject: preferSubject,
    issuer: preferIssuer,
    serial: preferSerial,
    rowSelectors
  }).catch(() => null);

  if (!selection?.ok) {
    log('error', 'No certificate entries available for selection');
    return { ok: false, error: 'No certificate entries available' };
  }
  log('info', `Certificate row selected index=${selection.index}`);

  if (!pinValue) {
    log('error', 'Certificate PIN value is empty');
    return { ok: false, error: 'Certificate PIN not provided' };
  }

  let pinHandle = null;
  for (const sel of pinSelectors) {
    if (!sel) continue;
    try {
      pinHandle = await scope.$(sel);
      if (pinHandle) break;
    } catch {}
  }
  if (!pinHandle) {
    log('error', 'Failed to locate certificate PIN input');
    return { ok: false, error: 'Certificate PIN input not found' };
  }

  try { await pinHandle.fill(''); } catch {}
  await pinHandle.type(pinValue, { delay: 40 }).catch(async () => { try { await pinHandle.fill(pinValue); } catch {} });
  await scope.evaluate((el, val) => {
    if (el) {
      el.value = val;
      el.dispatchEvent(new Event('input', { bubbles: true }));
    }
  }, pinHandle, pinValue).catch(() => {});

  let confirmHandle = null;
  for (const sel of confirmSelectors) {
    if (!sel) continue;
    try {
      confirmHandle = await scope.$(sel);
      if (confirmHandle) break;
    } catch {}
  }
  if (!confirmHandle) {
    log('error', 'Confirm button not found in certificate modal');
    return { ok: false, error: 'Certificate confirm button not found' };
  }

  const closePromise = certPage.waitForEvent('close', { timeout: Number(extra?.closeTimeoutMs) || 15000 }).catch(() => null);
  let confirmTriggered = false;

  if (pinHandle) {
    try {
      await pinHandle.focus();
      await pinHandle.press('Enter');
      confirmTriggered = true;
      log('info', 'Submitted PIN by pressing Enter');
    } catch {}
  }

  if (!confirmTriggered && certPage?.keyboard) {
    try {
      await certPage.keyboard.press('Enter');
      confirmTriggered = true;
      log('info', 'Submitted via page Enter key');
    } catch {}
  }

  if (!confirmTriggered) {
    try { await confirmHandle.focus(); } catch {}
    try {
      await confirmHandle.click({ delay: 40 });
      confirmTriggered = true;
      log('info', 'Confirm button clicked');
    } catch {}
  }

  if (!confirmTriggered) {
    const forced = await scope.evaluate(() => {
      const okSelector = '#nx-cert-select button.btn-ok, #browser-guide-added-wrapper button.btn-ok, .pki-bottom button.btn-ok';
      let okBtn = document.querySelector(okSelector);
      if (!okBtn) {
        okBtn = Array.from(document.querySelectorAll('#nx-cert-select button, .nx-cert-select button, button')).find((btn) => {
          const lbl = (btn.innerText || btn.textContent || '').trim();
          return lbl.includes('확인');
        });
      }
      if (okBtn) {
        okBtn.click();
        okBtn.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
        okBtn.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', bubbles: true }));
        return true;
      }
      if (window.NX_Issue_pubUi?.selectCertConfirm) {
        try { window.NX_Issue_pubUi.selectCertConfirm(); return true; } catch (e) {}
      }
      return false;
    }).catch(() => false);
    if (forced) {
      confirmTriggered = true;
      log('info', 'Confirm triggered via DOM evaluation fallback');
    }
  }

  if (!confirmTriggered) {
    log('warn', 'Confirm trigger attempt failed; modal may remain open');
  }

  await sleep(300);

  const identityValue = String(cert.identity || extra?.identity || extra?.company?.bizNo || '').replace(/[^0-9a-z]/gi, '');
  const identityHandled = await scope.evaluate((val) => {
    const panel = document.querySelector('#nx-cert-VerifyIdentify');
    if (!panel) return false;
    const style = window.getComputedStyle(panel);
    if (style.display === 'none' || panel.offsetWidth === 0 || panel.offsetHeight === 0) return false;
    const input = panel.querySelector('input');
    if (input && val) {
      input.value = val;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    }
    const btn = panel.querySelector('button.btn-ok') || panel.querySelector('button');
    if (btn) btn.click();
    return !!val;
  }, identityValue).catch(() => false);
  if (identityHandled) {
    log('info', 'Identity verification number submitted');
      await sleep(250);`; fs.writeFileSync(path, content, 'utf8');
